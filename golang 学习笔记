
1.     micro   rpc 创建客户端与服务端  


 /*                                                    protobuf  file                                              */

syntax = "proto3";

service Greeter {
    rpc Hello(HelloRequest) returns (HelloResponse) {}
}

message HelloRequest {
    string name = 1;
}

message HelloResponse {
    string greeting = 2;
}




/ *                                        service.go                         */   



package main

import (
	"fmt"
	"microedit/message"
	"net/http"
	"net/rpc"
	"net"
)

type Request message.HelloResponse

func (this *Request)Hello(request message.HelloRequest,response *message.HelloResponse)error{
	fmt.Println("service message",request.Name)
	response.Greeting = request.Name + "8080"
	return nil
}

func main(){

	rpc.Register(new(Request))
	rpc.HandleHTTP()

	ln,_:=net.Listen("tcp","127.0.0.1:8080")
	http.Serve(ln,nil)

}




/*                                client.go                             */


package main

import (
	"fmt"
	"microedit/message"
	"net/rpc"
)

func main() {
	var pp message.HelloResponse
	cli , _:=rpc.DialHTTP("tcp","127.0.0.1:8080")
	cli.Call("Request.Hello",message.HelloRequest{Name: "greeter point:"},&pp)

	fmt.Println("最后得到",&pp)
}



---------------------   gjson 的使用  -----------------------------
github.com/tidwall/gjson


const json = `{"name":{"first":"Janet","last":"Prichard"},"age":47}`

func main(){
	LastValue := gjson.Get(json,"name.last")
	fmt.Println(LastValue.string())
}

路径可能包含通配符'*'和'?'.
通过下标访问数组值.
通过'#'来获取值在元素中的排位或访问子路径.
.和通配符可以通过'\'来转义.

{
  "name": {"first": "Tom", "last": "Anderson"},
  "age":37,
  "children": ["Sara","Alex","Jack"],
  "fav.movie": "Deer Hunter",
  "friends": [
    {"first": "Dale", "last": "Murphy", "age": 44},
    {"first": "Roger", "last": "Craig", "age": 68},
    {"first": "Jane", "last": "Murphy", "age": 47}
  ]
}


"name.last"          >> "Anderson"
"age"                >> 37
"children"           >> ["Sara","Alex","Jack"]
"children.#"         >> 3
"children.1"         >> "Alex"
"child*.2"           >> "Jack"
"c?ildren.0"         >> "Sara"
"fav\.movie"         >> "Deer Hunter"
"friends.#.first"    >> ["Dale","Roger","Jane"]
"friends.1.last"     >> "Craig"


你同样能通过#[...]来查询数组中的第一个匹配的项, 或通过'#[...]#'查询所有匹配的项.
查询支持==, !=, <, <=, >, >=比较运算符和'%'模糊匹配.

friends.#[last=="Murphy"].first    >> "Dale"
friends.#[last=="Murphy"]#.first   >> ["Dale","Jane"]
friends.#[age>45]#.last            >> ["Craig","Murphy"]
friends.#[first%"D*"].last         >> "Murphy"


ForEachLines 方法可以迭代json.

gjson.ForEachLine(json, func(line gjson.Result) bool{
    println(line.String())
    return true
})


判断json是否合法

if !gjson.Valid(json) {
    return errors.New("invalid json")
}

将值反序列化到map

res ,ok :=gjson.parse(json).value().(map[string]interface{})
if !ok{
	fmt.Println("反序列化失败")
}





/* -------------------- reflect --------------------- */

// 通过放射使用结构体字段

type ReflectFactory struct {
	Name string
	Age int
}

func (s *ReflectFactory) A() {
	fmt.Println("A")
}

func (s *ReflectFactory) B() {
	fmt.Println("B")
}

func main() {
	r := ReflectFactory{Name:"Ellison"}

	field := "Name"

	res := reflect.ValueOf(&r).Elem().FieldByName(field).String()
	fmt.Println(res)
}



// 通过反射调用结构体对应的方法

type ReflectFactory struct {
	Name string
	Age int
}

func (s *ReflectFactory) A(action string) string {
	return action
}

func (s *ReflectFactory) B(action string) string {
	return action
}

func main() {
	r := ReflectFactory{Name:"Ellison"}

	// 方法名称
	field := "B"
	valueS := reflect.ValueOf(&r)
	method := valueS.MethodByName(field)
	params := []reflect.Value{
		reflect.ValueOf("song"), // 方法参数
	}
	res := method.Call(params)[0].String() // 返回的是字符串
	fmt.Println(res)
}




/* ----------------------------------- gin框架 ----------------------------------*/

//将request的body中数据,自动按照json格式解析到结构体
 r.POST("loginJSON", func(c *gin.Context) {
	var json Student
     	c.ShouldBindJSON(&json)
}

// 表单数据绑定
 r.POST("loginJSON", func(c *gin.Context) {
	var form Student
	c.Bind(&form)
}













